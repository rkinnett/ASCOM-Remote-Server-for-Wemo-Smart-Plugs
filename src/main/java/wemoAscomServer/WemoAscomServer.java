/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package wemoAscomServer;

import com.sun.net.httpserver.Headers;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpServer;
import java.awt.Color;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.URI;
import java.net.URLDecoder;
import java.net.UnknownHostException;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.ImageIcon;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import com.formdev.flatlaf.FlatDarkLaf;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.ItemEvent;
import java.awt.event.KeyEvent;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import javax.swing.SwingWorker;
import javax.swing.text.BadLocationException;




/**
 *
 * @author Ryan
 */
public class WemoAscomServer extends javax.swing.JFrame {
   private static final String HOSTNAME = "localhost";
    private static final int DEFAULT_SERVER_PORT = 8080;
    private static final int BACKLOG = 1;
    private static InetAddress wemoIPAddress = null;
    private static final int WEMO_PORT = 49153;
    
    private static final int IP_SCAN_MIN_SUFFIX = 2;
    private static final int IP_SCAN_MAX_SUFFIX = 255;
    private static final int IP_SCAN_TIMEOUT_MILLIS = 200;
                
    private static HttpServer server = null;

    private static final String HEADER_CONTENT_TYPE = "Content-Type";
    private static final Charset CHARSET = StandardCharsets.UTF_8;
    private static final int STATUS_OK = 200;
    private static final String METHOD_GET = "GET";
    private static final String METHOD_PUT = "PUT";

    private static String DEVICE_NAME = "Wemo Switch";
    private static String DEVICE_DESCRIPTION = "Wemo Smart Plug";
    private static final String DRIVER_INFO = "my wemo driver";
    private static final String DRIVER_VER = "0";
    private static final String INTERFACE_VER = "1";
    
    public enum LogLevel {
        OFF,
        ERROR,
        EVENT,
        STATUS,
        INFO,
        DEBUG,
        ALL,
    }
    public static LogLevel LOGLEVEL = LogLevel.STATUS;
    public static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");
    public static final int MAX_LOG_LINE_COUNT = 1000;

    public static Boolean serverStarted = false;
    public static Boolean clientConnected = false;
    public static int ServerTransactionCount = 0;
    public static String ClientTransactionID;
    public static Boolean switchAccessible = false;
    public static Boolean switchIsOn = false;
    public static Boolean scanning = false;
    
    /**
     * Creates new form WemoAscomServerGUI
     */
    public WemoAscomServer() {       
        initComponents();
        setIcon();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        labelClientConnectionIndicator = new javax.swing.JLabel();
        labelSwitchStateIndicator = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        buttonStartServer = new javax.swing.JButton();
        buttonToggleSwitch = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        logTextArea = new javax.swing.JTextArea();
        textboxSwitchIP = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        labelServerRunningIndicator = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        buttonScan = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JSeparator();
        jSeparator2 = new javax.swing.JSeparator();
        jLabel3 = new javax.swing.JLabel();
        comboLogLevel = new javax.swing.JComboBox<>();
        buttonSetIP = new javax.swing.JButton();
        checkboxAutoscroll = new javax.swing.JCheckBox();
        scanProgressBar = new javax.swing.JProgressBar();
        buttonClearLog = new javax.swing.JButton();
        buttonCopyLog = new javax.swing.JButton();
        serverPortTextArea = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Wemo ASCOM Server");
        setName("GuiFrame"); // NOI18N
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowActivated(java.awt.event.WindowEvent evt) {
                formWindowActivated(evt);
            }
            public void windowOpened(java.awt.event.WindowEvent evt) {
                formWindowOpened(evt);
            }
        });

        labelClientConnectionIndicator.setFont(new java.awt.Font("SansSerif", 1, 12)); // NOI18N
        labelClientConnectionIndicator.setForeground(java.awt.Color.red);
        labelClientConnectionIndicator.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        labelClientConnectionIndicator.setText("X");
        labelClientConnectionIndicator.setToolTipText("Reflects a connection status value controlled by the client.");

        labelSwitchStateIndicator.setFont(new java.awt.Font("SansSerif", 1, 12)); // NOI18N
        labelSwitchStateIndicator.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        labelSwitchStateIndicator.setText("?");

        jLabel4.setText("Client connected:");

        jLabel2.setText("Switch state:");

        buttonStartServer.setText("Start Server");
        buttonStartServer.setToolTipText("Begins listening for and handling ASCOM commands on port 8080.");
        buttonStartServer.setEnabled(false);
        buttonStartServer.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonStartServerActionPerformed(evt);
            }
        });

        buttonToggleSwitch.setText("Toggle");
        buttonToggleSwitch.setToolTipText("Toggles switch state (from off to on or  on to off)");
        buttonToggleSwitch.setEnabled(false);
        buttonToggleSwitch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonToggleSwitchActionPerformed(evt);
            }
        });

        logTextArea.setEditable(false);
        logTextArea.setColumns(20);
        logTextArea.setRows(5);
        logTextArea.setToolTipText("Log area displays state and debug info per Log Level setting. Buffers " + MAX_LOG_LINE_COUNT + " lines.");
        jScrollPane2.setViewportView(logTextArea);

        textboxSwitchIP.setForeground(new java.awt.Color(255, 153, 153));
        textboxSwitchIP.setText("IP Address");
        textboxSwitchIP.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                textboxSwitchIPActionPerformed(evt);
            }
        });
        textboxSwitchIP.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                textboxSwitchIPKeyReleased(evt);
            }
            public void keyTyped(java.awt.event.KeyEvent evt) {
                textboxSwitchIPKeyTyped(evt);
            }
        });

        jLabel5.setText("Server started:");

        labelServerRunningIndicator.setFont(new java.awt.Font("SansSerif", 1, 12)); // NOI18N
        labelServerRunningIndicator.setForeground(java.awt.Color.red);
        labelServerRunningIndicator.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        labelServerRunningIndicator.setText("X");

        jLabel1.setText("Switch IP:");

        buttonScan.setText("Start scan");
        buttonScan.setToolTipText("Scans IP address suffix range " + IP_SCAN_MIN_SUFFIX + " to " + IP_SCAN_MAX_SUFFIX + " for Wemo switches and displays info in log area.");
        buttonScan.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonScanActionPerformed(evt);
            }
        });

        jLabel3.setText("Log Level:");

        comboLogLevel.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "NONE", "ERROR", "EVENT", "STATUS", "INFO", "DEBUG", "ALL" }));
        comboLogLevel.setSelectedIndex(3);
        comboLogLevel.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                comboLogLevelItemStateChanged(evt);
            }
        });

        buttonSetIP.setText("Set");
        buttonSetIP.setToolTipText("Checks for open port at specified address and enables switch control");
        buttonSetIP.setEnabled(false);
        buttonSetIP.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonSetIPActionPerformed(evt);
            }
        });

        checkboxAutoscroll.setSelected(true);
        checkboxAutoscroll.setText("Autoscroll");

        scanProgressBar.setMaximum(IP_SCAN_MAX_SUFFIX);
        scanProgressBar.setToolTipText("scan progress");

        buttonClearLog.setText("Clear");
        buttonClearLog.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonClearLogActionPerformed(evt);
            }
        });

        buttonCopyLog.setText("Copy");
        buttonCopyLog.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonCopyLogActionPerformed(evt);
            }
        });

        serverPortTextArea.setText("" + DEFAULT_SERVER_PORT);
        serverPortTextArea.setToolTipText("TCP Port for communication with your astronomy software");

        jLabel6.setText("Server Port:");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2)
                    .addComponent(jSeparator2, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jSeparator1)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel6)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(serverPortTextArea, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(buttonStartServer, javax.swing.GroupLayout.PREFERRED_SIZE, 91, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel5)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(labelServerRunningIndicator, javax.swing.GroupLayout.PREFERRED_SIZE, 17, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jLabel4))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(textboxSwitchIP, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(buttonSetIP, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(buttonScan)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(scanProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(buttonToggleSwitch, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel2)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(labelClientConnectionIndicator, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(labelSwitchStateIndicator, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(comboLogLevel, javax.swing.GroupLayout.PREFERRED_SIZE, 93, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(buttonClearLog, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(buttonCopyLog, javax.swing.GroupLayout.PREFERRED_SIZE, 66, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(checkboxAutoscroll, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(9, 9, 9)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(scanProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(textboxSwitchIP, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabel1)
                        .addComponent(jLabel2)
                        .addComponent(labelSwitchStateIndicator, javax.swing.GroupLayout.PREFERRED_SIZE, 16, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(buttonToggleSwitch)
                        .addComponent(buttonScan)
                        .addComponent(buttonSetIP)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 11, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 13, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(labelServerRunningIndicator)
                    .addComponent(labelClientConnectionIndicator)
                    .addComponent(jLabel4)
                    .addComponent(buttonStartServer, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(serverPortTextArea, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel6))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 11, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(comboLogLevel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(checkboxAutoscroll)
                    .addComponent(buttonClearLog)
                    .addComponent(buttonCopyLog))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 405, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void buttonStartServerActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonStartServerActionPerformed
        // Start ASCOM Server if not already running and if switch is accessible:
        if(!serverStarted){
            if(switchAccessible){
                appendLog(LogLevel.EVENT, "Starting ASCOM device server");
                serverStarted =  startAscomServer();
                buttonStartServer.setText("Server started");
                buttonStartServer.setEnabled(false);
            } else {
                appendLog(LogLevel.ERROR, "Can't start ASCOM server while switch is inaccessible.");
                appendLog(LogLevel.ERROR, "Please verify your switch is on the network, or try a different address.");
            }  
        } else {
            appendLog(LogLevel.ERROR, "Server already started");
        }
        
        appendLogBlankLine(LogLevel.EVENT);
    }//GEN-LAST:event_buttonStartServerActionPerformed

    private void buttonToggleSwitchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonToggleSwitchActionPerformed
        appendLog(LogLevel.EVENT, "Toggling switch state from " + (switchIsOn?"on":"off") + " to " + (!switchIsOn?"on":"off"));
        wemoSetSwitchState(switchIsOn=!switchIsOn);
        appendLogBlankLine(LogLevel.EVENT);
    }//GEN-LAST:event_buttonToggleSwitchActionPerformed

    private void textboxSwitchIPActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_textboxSwitchIPActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_textboxSwitchIPActionPerformed

    private void formWindowActivated(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowActivated
             
    }//GEN-LAST:event_formWindowActivated

    private void textboxSwitchIPKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_textboxSwitchIPKeyTyped
        // TODO add your handling code here:
    }//GEN-LAST:event_textboxSwitchIPKeyTyped

    private void textboxSwitchIPKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_textboxSwitchIPKeyReleased
        final String strSwitchIP = textboxSwitchIP.getText();        
        final Boolean userEnteredValidIP = checkIPFormat(strSwitchIP);
        if(userEnteredValidIP){
            textboxSwitchIP.setForeground(new Color(200, 200, 200));
            buttonSetIP.setEnabled(true);
            
            if (evt.getKeyCode() == KeyEvent.VK_ENTER) {
                System.out.println("ENTER key pressed");
                setSwitchIP();
            }
            
        } else {
            textboxSwitchIP.setForeground(new Color(255, 153, 153));  
            buttonSetIP.setEnabled(false);
        }
    }//GEN-LAST:event_textboxSwitchIPKeyReleased

    private void formWindowOpened(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowOpened
        scanProgressBar.setVisible(false);
        try {
            // TODO add your handling code here:
            InetAddress IP=InetAddress.getLocalHost();
            appendLog(LogLevel.INFO, "IP of this system is "+IP.getHostAddress());
            appendLogBlankLine(LogLevel.INFO);
            String baseIp = IP.getHostAddress().replaceAll("[0-9]+$", "???");
            textboxSwitchIP.setText(baseIp);
        } catch (UnknownHostException ex) {
            Logger.getLogger(WemoAscomServer.class.getName()).log(Level.SEVERE, null, ex);
            appendLog(LogLevel.ERROR, "Program error: " + ex);
        }
        
        appendLog(LogLevel.EVENT, "STEP 1:  Enter switch IP and press enter key or Set button.");
        appendLogBlankLine(LogLevel.EVENT);
    }//GEN-LAST:event_formWindowOpened

    private void comboLogLevelItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_comboLogLevelItemStateChanged
        // TODO add your handling code here:
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            LOGLEVEL = LogLevel.values()[comboLogLevel.getSelectedIndex()];
            appendLogBlankLine(LogLevel.EVENT);
            appendLog(LogLevel.EVENT, "Changed log level to: " + LOGLEVEL.toString());
            appendLogBlankLine(LogLevel.EVENT);
        }
    }//GEN-LAST:event_comboLogLevelItemStateChanged

    private void buttonSetIPActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonSetIPActionPerformed
       // hardcode switch IP for easier dev:
        //final String strSwitchIP = "192.168.1.5";
        
        // Get switch IP from textbox:
        final String strSwitchIP = textboxSwitchIP.getText();                
        final Boolean userEnteredValidIP = checkIPFormat(strSwitchIP);
        if(!userEnteredValidIP){
            appendLog(LogLevel.ERROR, "User entered invalid IP address");
            return;
        }
        setSwitchIP();
    }//GEN-LAST:event_buttonSetIPActionPerformed

    private void buttonScanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonScanActionPerformed
        if(!scanning){
            startScan();
        } else {
            appendLog(LogLevel.EVENT, "Stopping scan.");
            scanning = false;
        }
    }//GEN-LAST:event_buttonScanActionPerformed

    private void buttonClearLogActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonClearLogActionPerformed
        logTextArea.setText("");
    }//GEN-LAST:event_buttonClearLogActionPerformed

    private void buttonCopyLogActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonCopyLogActionPerformed
        StringSelection stringSelection = new StringSelection (logTextArea.getText());
        Clipboard clpbrd = Toolkit.getDefaultToolkit ().getSystemClipboard ();
        clpbrd.setContents (stringSelection, null);
    }//GEN-LAST:event_buttonCopyLogActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {        
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
        * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
        */
           
        /*
        try {           
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex) {
            Logger.getLogger(WemoAscomServer.class.getName()).log(Level.SEVERE, null, ex);
            appendLog(LogLevel.ERROR, "Program error: " + ex);
        }    
        */
        
        /*
        // Lists available Looks&Feels, and sets form to use specified LAF.
        String lafName = "Metal";
        try {            
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                System.out.println("  Available LAF: " + info.getName());
                if (lafName.equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    //break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(WemoAscomServer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        */           
        
        try {
            UIManager.setLookAndFeel( new FlatDarkLaf() );
        } catch( UnsupportedLookAndFeelException ex ) {
            System.err.println( "Failed to initialize LaF" );
        }       
       
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
       
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>


        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new WemoAscomServer().setVisible(true);
        });
    }

    
    private void startScan() { 
        SwingWorker sw1 = new SwingWorker() { 
            
            @Override
            protected String doInBackground() throws Exception { 
                scanning = true;
                buttonScan.setText("Stop scan");
                buttonScan.setForeground(new java.awt.Color(230, 200, 160)  );
                scanProgressBar.setMinimum(IP_SCAN_MIN_SUFFIX);
                scanProgressBar.setMaximum(IP_SCAN_MAX_SUFFIX);        
                scanProgressBar.setVisible(true);

                final Duration timeout = Duration.ofMillis(IP_SCAN_TIMEOUT_MILLIS);
                var client = HttpClient.newHttpClient();

                String IPmask;
                try {                    
                    IPmask = InetAddress.getLocalHost().getHostAddress().replaceAll("[0-9]+$", "");
                } catch (UnknownHostException ex) {
                    Logger.getLogger(WemoAscomServer.class.getName()).log(Level.SEVERE, null, ex);
                    return "";
                }   

                appendLog(LogLevel.EVENT, "Probing port " + WEMO_PORT + " in IP range " + IPmask + IP_SCAN_MIN_SUFFIX + " to " + IPmask + IP_SCAN_MAX_SUFFIX);           
                appendLogBlankLine(LogLevel.EVENT);

                for (int i=IP_SCAN_MIN_SUFFIX; i<=IP_SCAN_MAX_SUFFIX; i++){
                    if(!scanning) return "";
                    
                    String testIP = IPmask + i; 
                    String urlStr = "http://" + testIP + ":" + WEMO_PORT; 
                    appendLog(LogLevel.INFO, "Probing " + urlStr);
                    URI uri = URI.create(urlStr);

                    var request = HttpRequest.newBuilder(uri).timeout(timeout).build();
                    HttpResponse response = null;
                    try {
                        response = client.send(request, HttpResponse.BodyHandlers.ofString());
                    } catch (IOException | InterruptedException ex) {
                        //Logger.getLogger(WemoAscomServer.class.getName()).log(Level.SEVERE, null, ex);
                        appendLog(LogLevel.DEBUG, "Program error: " + ex.getMessage());
                    }
                    Boolean reachable = (response!=null && response.statusCode()==404);
                    if(reachable){
                        appendLog(LogLevel.EVENT, "Found open port " + WEMO_PORT + " at " + testIP);
                        
                        var switchInfo = wemoGetSwitchInfo(testIP);
                        if(switchInfo.containsKey("friendlyName")){
                            appendLog(LogLevel.EVENT, "  Switch name: " + switchInfo.get("friendlyName"));
                        }
                        if(switchInfo.containsKey("binaryState")){
                            appendLog(LogLevel.EVENT, "  Switch state: " + ("1".equals(switchInfo.get("binaryState"))?"ON":"OFF"));
                        }     
                        appendLogBlankLine(LogLevel.EVENT);
                    } else {
                        appendLog(LogLevel.DEBUG, "Port unreachable at " + urlStr);
                    }
                    scanProgressBar.setValue(i);
                    
                }
                return ""; 
            }
            
            @Override
            protected void done()  {
                appendLog(LogLevel.STATUS, "Done.");
                appendLogBlankLine(LogLevel.STATUS);
                buttonScan.setText("Start scan");
                buttonScan.setForeground(new java.awt.Color(187, 187, 187)  );
                scanProgressBar.setVisible(false);
            }             
        }; 
        sw1.execute();  
    } 
    
    private void setSwitchIP() {                                            
        // Get switch IP from textbox:
        final String strSwitchIP = textboxSwitchIP.getText();                
        final Boolean userEnteredValidIP = checkIPFormat(strSwitchIP);
        if(!userEnteredValidIP){
            appendLog(LogLevel.ERROR, "User entered invalid IP address");
            return;
        }
       
        // Check if Wemo switch is accessible:
        try {
            wemoIPAddress = InetAddress.getByName(strSwitchIP);
            appendLog(LogLevel.INFO, "Switch IP address: " + wemoIPAddress.getHostAddress());

            switchAccessible = wemoTestConnection(wemoIPAddress.getHostAddress());
            appendLog(switchAccessible?LogLevel.EVENT:LogLevel.ERROR,  switchAccessible?"  Switch TCP port is open":"  Switch is unreachable");
            if(switchAccessible){
                appendLog(LogLevel.STATUS, "Setting target switch IP to " + strSwitchIP);
                buttonToggleSwitch.setEnabled(true);
                
                wemoGetSwitchState();
                
                var switchInfo = wemoGetSwitchInfo(wemoIPAddress.getHostAddress());
                if(switchInfo.containsKey("friendlyName")){
                    DEVICE_NAME = "Wemo Switch (\"" + switchInfo.get("friendlyName") + "\")";
                    appendLog(LogLevel.STATUS, "  Switch name: " + switchInfo.get("friendlyName"));
                }
                if(switchInfo.containsKey("binaryState")){
                    appendLog(LogLevel.EVENT, "  Switch state: " + ("1".equals(switchInfo.get("binaryState"))?"ON":"OFF"));
                }
                if(switchInfo.containsKey("modelDescription")){
                    DEVICE_DESCRIPTION = switchInfo.get("modelDescription");             
                }
                appendLogBlankLine(LogLevel.EVENT);
                
                if(!serverStarted){
                    appendLog(LogLevel.DEBUG, "Enabling Start Server button");
                    buttonStartServer.setEnabled(true);
                    
                    appendLog(LogLevel.EVENT, "STEP 2:  Start Server.");
                    appendLogBlankLine(LogLevel.EVENT);
                }
                
            } else {
                buttonToggleSwitch.setEnabled(false);
            }
        } catch (UnknownHostException ex) {
            Logger.getLogger(WemoAscomServer.class.getName()).log(Level.SEVERE, null, ex);
            appendLog(LogLevel.ERROR, "Program error: " + ex);
        }
    }  
    
    
        
    private Void setIcon(){
        // the path must be relative to the src/resources folder
        java.net.URL imageURL = WemoAscomServer.class.getResource("/power_64.png");        
        //System.out.println(imageURL!=null?"found icon":"can't find icon");
        if (imageURL != null) {
            //System.out.println(imageURL.toString());
            ImageIcon icon = new ImageIcon(imageURL);
            setIconImage(icon.getImage());
        }
        return null;        
    }
    
    
    public boolean checkIPFormat (String ip) {
        try {
            if ( ip == null || ip.isEmpty() ) {
                return false;
            }

            String[] parts = ip.split( "\\." );
            if ( parts.length != 4 ) {
                return false;
            }

            for ( String s : parts ) {
                int i = Integer.parseInt( s );
                if ( (i < 0) || (i > 255) ) {
                    return false;
                }
            }
            return !ip.endsWith(".");
        } catch (NumberFormatException ex) {
            return false;
        }
    }
            
    private Boolean sendResponse(HttpExchange he, String value){
        String reply = "{";
        if(value!=null) reply += "Value:'" + value + "',";
        reply += "ClientTransactionID:" + ClientTransactionID + ","
               + "ServerTransactionID:" + ServerTransactionCount + ","
               + "ErrorNumber:0,"
               + "ErrorMessage:''"
               + "}";
        appendLog(LogLevel.INFO, "Sending reply: " + reply);
        final var rawResponseBody = reply.getBytes(CHARSET);
        try {
            he.sendResponseHeaders(STATUS_OK, rawResponseBody.length);
        } catch (IOException ex) {
            Logger.getLogger(WemoAscomServer.class.getName()).log(Level.SEVERE, null, ex);
            appendLog(LogLevel.ERROR, "Program error: " + ex);
            return false;
        }
        try {
            he.getResponseBody().write(rawResponseBody);
        } catch (IOException ex) {
            Logger.getLogger(WemoAscomServer.class.getName()).log(Level.SEVERE, null, ex);
            appendLog(LogLevel.ERROR, "Program error: " + ex);
            return false;
        }
        return true;
    }                

    
    
    private Map<String, List<String>> parseBody(HttpExchange he) throws UnsupportedEncodingException {
        Map<String, List<String>> requestParameters = new LinkedHashMap<>();
        try (InputStreamReader isr = new InputStreamReader(he.getRequestBody(),"utf-8")) {
            try (BufferedReader reader = new BufferedReader(isr)) {
                final String line = reader.readLine();
                appendLog(LogLevel.INFO, "Body:  " + line);        
                reader.close();
                requestParameters = getParameters(line);
            }
            isr.close();
        } catch (IOException ex) {
            Logger.getLogger(WemoAscomServer.class.getName()).log(Level.SEVERE, null, ex);
            appendLog(LogLevel.ERROR, "Program error: " + ex);
        } 
        return requestParameters;
    } 
    
    private Map<String, List<String>> getParameters(final String parameterString) {
        final Map<String, List<String>> requestParameters = new LinkedHashMap<>();
        if (parameterString != null) {
            final String[] rawRequestParameters = parameterString.split("[?&;]", -1);
            for (final String rawRequestParameter : rawRequestParameters) {
                final String[] requestParameter = rawRequestParameter.split("=", 2);
                final String requestParameterName = decodeUrlComponent(requestParameter[0]);
                requestParameters.putIfAbsent(requestParameterName, new ArrayList<>());
                final String requestParameterValue = requestParameter.length > 1 ? decodeUrlComponent(requestParameter[1]) : null;
                //appendLog(requestParameterName + ": " + requestParameterValue);
                requestParameters.get(requestParameterName).add(requestParameterValue);
            }
        }
        return requestParameters;
    }

    private String decodeUrlComponent(final String urlComponent) {
        try {
            return URLDecoder.decode(urlComponent, CHARSET.name());
        } catch (final UnsupportedEncodingException ex) {
            appendLog(LogLevel.ERROR, "Program error: " + ex);
            throw new InternalError(ex);
        }
    }
    
    private Boolean wemoTestConnection(String IPAddrStr) {
        String urlStr = "http://" + IPAddrStr + ":" + WEMO_PORT; 
        appendLog(LogLevel.DEBUG, "Looking for switch at " + urlStr);
        final Duration timeout = Duration.ofMillis(200);
        URI uri = URI.create(urlStr);
        var client = HttpClient.newHttpClient();
        var request = HttpRequest.newBuilder(uri).timeout(timeout).build();
        HttpResponse response = null;
        try {
            response = client.send(request, HttpResponse.BodyHandlers.ofString());
        } catch (IOException | InterruptedException ex) {
            //Logger.getLogger(WemoAscomServer.class.getName()).log(Level.SEVERE, null, ex);
            appendLog(LogLevel.DEBUG, "Program error: " + ex.getMessage());
        }
        Boolean reachable = (response!=null && response.statusCode()==404);
        appendLog(LogLevel.DEBUG, reachable?"  Switch TCP port is open":"  Switch is unreachable");
        return reachable;
    }

    public Map<String, String>  wemoGetSwitchInfo(String ipStr){
        Map<String, String> switchInfo = new HashMap<>();
        appendLog(LogLevel.STATUS, "Getting switch info");
        String urlStr = "http://" + ipStr + ":" + WEMO_PORT + "/setup.xml";
        appendLog(LogLevel.DEBUG, "  Making GET request to " + urlStr);
        var client = HttpClient.newHttpClient();
        var request = HttpRequest.newBuilder(URI.create(urlStr)).build();
        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            String responseBody = response.body();
            appendLog((response.statusCode()==200)?LogLevel.DEBUG:LogLevel.ERROR, "  Response status code: " + response.statusCode());                
            appendLog((response.statusCode()==200)?LogLevel.DEBUG:LogLevel.ERROR, "  Response body: " + response.body());
            
            final String[] fieldNames = {"friendlyName", "modelName", "modelDescription", "binaryState", "macAddress", "serialNumber"};
            for (String fieldName : fieldNames ){
                String fieldVal = "";
                if(responseBody.contains(fieldName)){
                    fieldVal = (response.body().split("<" + fieldName + ">")[1].split("</" + fieldName + ">")[0]);
                    switchInfo.put(fieldName, fieldVal);
                }
                appendLog(LogLevel.DEBUG, "  " + fieldName + ": " + fieldVal);
            }

        } catch (IOException | InterruptedException ex) {
            Logger.getLogger(WemoAscomServer.class.getName()).log(Level.SEVERE, null, ex);
            appendLog(LogLevel.ERROR, "Program error: " + ex);
        }
        return switchInfo;
    }
    
    private Boolean wemoGetSwitchState(){
        Boolean switchState = switchIsOn;
        appendLog(LogLevel.INFO, "Checking switch state");
        String requestBody = "<?xml version=\"1.0\" encoding=\"utf-8\"?> "
                + "<s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"> "
                + "<s:Body> <u:GetBinaryState xmlns:u=\"urn:Belkin:service:basicevent:1\"/> </s:Body> </s:Envelope>";
        final HttpResponse<String> response = wemoHttpRequest(requestBody);
        if(response.statusCode()==200) {
            final Map<String, List<String>> requestParameters;            
            final String binaryState = (response.body().split("<BinaryState>")[1].split("</BinaryState>")[0]);
            appendLog(LogLevel.DEBUG, "  BinaryState: " + binaryState);
            switchState = ("1".equals(binaryState));
            switchIsOn = switchState;
            appendLog(LogLevel.INFO, "  Switch state: " + (switchIsOn?"on":"off"));            
        }
        labelSwitchStateIndicator.setText((switchState?"ON":"OFF"));
        labelSwitchStateIndicator.setForeground((switchState? new java.awt.Color(230, 200, 160) : new java.awt.Color(110, 125, 150)));

        return switchState;
    }
    
    private Boolean wemoSetSwitchState(Boolean to_value){
        Boolean succeeded = false;
        final int setVal = to_value?1:0;
        String urlStr = "http://" + wemoIPAddress.getHostAddress() + ":" + WEMO_PORT + "/upnp/control/basicevent1";
        appendLog(LogLevel.DEBUG, "  Making POST request to " + urlStr);

        String requestBody = "<?xml version=\"1.0\" encoding=\"utf-8\"?>"
                + "<s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"> "
                + "<s:Body> <u:SetBinaryState xmlns:u=\"urn:Belkin:service:basicevent:1\"> "
                + "<BinaryState>" + setVal + "</BinaryState> "
                + "</u:SetBinaryState> </s:Body> </s:Envelope>";
        appendLog(LogLevel.DEBUG, "  request body: " + requestBody);
                
        final HttpResponse<String> response = wemoHttpRequest(requestBody);
        if(response.statusCode()==200) {
            succeeded = true;
            switchIsOn = wemoGetSwitchState();
            appendLog(LogLevel.EVENT, "Switch state set to " + (switchIsOn?"on":"off"));            
        }
        appendLog(LogLevel.DEBUG, "Switch state: " + (switchIsOn?"on":"off"));            
        return succeeded;      
    }
    
    private HttpResponse<String>  wemoHttpRequest(String requestBody ){
        HttpResponse<String> response = null;
        Boolean succeeded = false;
        String wemoCommand = (requestBody.contains("SetBinaryState")? "SetBinaryState" : "GetBinaryState");
        
        final String urlStr = "http://" + wemoIPAddress.getHostAddress() + ":" + WEMO_PORT + "/upnp/control/basicevent1";
        appendLog(LogLevel.DEBUG, "  Making POST request to " + urlStr);
        
        var client = HttpClient.newHttpClient();
        
        List<String> headers = new ArrayList<>();
        headers.add("User-Agent");      headers.add("");
        headers.add("Content-type");    headers.add("text/xml; charset=\"utf-8\"");
        headers.add("SOAPACTION");      headers.add("\"urn:Belkin:service:basicevent:1#" + wemoCommand + "\"");
        
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(urlStr))
            .headers(headers.toArray(String[]::new))
            .POST(HttpRequest.BodyPublishers.ofString(requestBody))
            .build();        
            
        try {
            response = client.send(request, HttpResponse.BodyHandlers.ofString());
            appendLog((response.statusCode()==200)?LogLevel.DEBUG:LogLevel.ERROR, "  Response status code: " + response.statusCode());                
            appendLog((response.statusCode()==200)?LogLevel.DEBUG:LogLevel.ERROR, "  Response body: " + response.body());
        } catch (IOException | InterruptedException ex) {
            Logger.getLogger(WemoAscomServer.class.getName()).log(Level.SEVERE, null, ex);
            appendLog(LogLevel.ERROR, "Program error: " + ex);
        }        
        return response;
    }
        
    private void appendLogBlankLine(LogLevel levelThisEntry){
        if(LOGLEVEL.compareTo(levelThisEntry)>=0){
            logTextArea.append("\n");
        }
    }

    private void appendLog(LogLevel levelThisEntry, String str) {     
        String dateStr = LocalDateTime.now().format(DATE_FORMAT);
        if(LOGLEVEL.compareTo(levelThisEntry)>=0){
            logTextArea.append("[" + dateStr + "]  " + str + "\n");
        }
        
        while(logTextArea.getLineCount()>MAX_LOG_LINE_COUNT ){
            try {
                logTextArea.replaceRange("", 0, logTextArea.getLineEndOffset(0));
            } catch (BadLocationException ex) {
                Logger.getLogger(WemoAscomServer.class.getName()).log(Level.SEVERE, null, ex);
                appendLog(LogLevel.ERROR, "Program error: " + ex);
            }
        }
        
        if(checkboxAutoscroll.isSelected()){
            logTextArea.setCaretPosition(logTextArea.getText().length());
        }
    }
    
    private Boolean startAscomServer() {
        Boolean started = false;
        
        int serverPort = Integer.parseInt(serverPortTextArea.getText());
        if(serverPort<1 || serverPort>65536){
            appendLog(LogLevel.ERROR, "Invalid port; please specify integer between 1 and 65536)");
            return false;
        }
        
        try {
            server = HttpServer.create(new InetSocketAddress(HOSTNAME, serverPort), BACKLOG);
        } catch (IOException ex) {
            Logger.getLogger(WemoAscomServer.class.getName()).log(Level.SEVERE, null, ex);
            appendLog(LogLevel.ERROR, "Program error: " + ex);
        }
        
        server.createContext("/", (HttpExchange he) -> {
            appendLogBlankLine(LogLevel.EVENT);
            try (he) {
                final String clientAddr = he.getRemoteAddress().toString().split("/")[1].split(":")[0];
                final String requestMethod = he.getRequestMethod().toUpperCase();
                final String requestURI = he.getRequestURI().toString();
                final String ascomCommand = requestURI.substring(requestURI.lastIndexOf('/')+1).split("[&?]")[0];
                appendLog(LogLevel.EVENT, "Client " + clientAddr + " requested "+ requestMethod + " " + ascomCommand);
                
                appendLog(LogLevel.DEBUG, "URI: " + requestURI);
                
                final Map<String, List<String>> requestParameters;
                if(METHOD_PUT.equals(requestMethod)){
                    requestParameters = parseBody(he);                    
                } else {
                    requestParameters = getParameters(requestURI);
                }
                appendLog(LogLevel.INFO, "parameters: " + requestParameters);
                                                
                ClientTransactionID = requestParameters.get("ClientTransactionID").toString().replaceAll("[\\[\\](){}]","");
                appendLog(LogLevel.DEBUG, "ClientTransactionID: " + ClientTransactionID);

                final Headers responseHeaders = he.getResponseHeaders();
                responseHeaders.set(HEADER_CONTENT_TYPE, String.format("application/json; charset=%s", CHARSET));
                
                switch (requestMethod) {
                    
                    case METHOD_GET -> {
                        switch (ascomCommand) {
                            // Handle common GET methods for all ASCOM devices: 
                            case "connected"        -> { sendResponse(he, clientConnected.toString()); }
                            case "name"             -> { sendResponse(he, DEVICE_NAME); }
                            case "description"      -> { sendResponse(he, DEVICE_DESCRIPTION); }
                            case "driverinfo"       -> { sendResponse(he, DRIVER_INFO); }
                            case "driverversion"    -> { sendResponse(he, DRIVER_VER); }
                            case "interfaceversion" -> { sendResponse(he, INTERFACE_VER); }
                            case "supportedactions" -> { sendResponse(he, "[\"setswitch\"]"); }
                            
                            // Handle switch-specific GET methods:
                            case "maxswitch"        -> { sendResponse(he, "1"); }
                            case "canwrite"         -> { sendResponse(he, "True"); }
                            case "getswitch"        -> { sendResponse(he, wemoGetSwitchState().toString()); }
                            case "getswitchdescription" -> { sendResponse(he, DEVICE_DESCRIPTION); }  // intentionally switched
                            case "getswitchname"    -> { sendResponse(he, DEVICE_NAME); }  // intentionally switched
                            case "getswitchvalue"   -> { sendResponse(he, wemoGetSwitchState()?"1":"0"); } // swtich "value" as double (duty cycle)
                            case "minswitchvalue"   -> { sendResponse(he, "0"); }
                            case "maxswitchvalue"   -> { sendResponse(he, "1"); }
                            case "switchstep"       -> { sendResponse(he, "1"); }
                            
                            default          -> {
                                appendLog(LogLevel.ERROR, "Unrecognized GET request");
                                // fixme:  send "not implemented" error to client
                            }
                        }                        
                    }    
                    
                    case METHOD_PUT -> {
                        switch (ascomCommand) {
                            // Handle common PUT mehods for all ASCOM devices:
                            case "connected" -> {  
                                appendLog(LogLevel.INFO, "Client asserts connection state");
                                clientConnected = ("[True]".equals(requestParameters.get("Connected").toString()));
                                appendLog(LogLevel.STATUS, "State set to: " + (clientConnected ? "Connected" : "Disconnected"));
                                sendResponse(he, null);
                                labelClientConnectionIndicator.setText(clientConnected?"\u2713":"X");
                                labelClientConnectionIndicator.setForeground(clientConnected?Color.GREEN:Color.RED);
                            }
                            case "action"        -> { sendResponse(he, "OK"); }
                            case "commandblind"  -> { sendResponse(he, null); }
                            case "commandbool"   -> { sendResponse(he, "True"); }
                            case "commandstring" -> { sendResponse(he, "OK"); }
                            
                            // Handle switch-specific PUT commands:
                            case "setswitch"        -> { 
                                final Boolean to_state = ("[True]".equals(requestParameters.get("State").toString()));
                                appendLog(LogLevel.STATUS, "Setting state to " + (to_state ? "On" : "Off"));
                                wemoSetSwitchState(to_state);
                                sendResponse(he, null); 
                            }
                            case "setswitchname"    -> { sendResponse(he, "OK"); }
                            case "setswitchvalue"   -> { 
                                final Boolean to_state = ("[1]".equals(requestParameters.get("Value").toString()));
                                appendLog(LogLevel.STATUS, "Setting state to " + (to_state ? "On" : "Off"));
                                wemoSetSwitchState(to_state);
                                sendResponse(he, null); 
                            }                            
                            default          -> {
                                appendLog(LogLevel.ERROR, "Unrecognized PUT request");
                                // fixme:  send "not implemented" error to client
                            }                            
                        }
                    }
                    
                    default -> {
                        appendLog(LogLevel.ERROR, "Unexpected HTTP Method: " + requestMethod);
                    }
                }
                appendLog(LogLevel.INFO, "done");
            } 

            finally {
                ServerTransactionCount++;
            }
        });
        
        server.start();
        labelServerRunningIndicator.setText("\u2713");
        labelServerRunningIndicator.setForeground(Color.GREEN);
        appendLog(LogLevel.EVENT, "Server started.  Listening...");
        
        appendLogBlankLine(LogLevel.EVENT);
        appendLog(LogLevel.EVENT, "STEP 3:  Connect to this proxy from your ASCOM client.");
        appendLogBlankLine(LogLevel.EVENT);
                    
        return true;
    }        
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton buttonClearLog;
    private javax.swing.JButton buttonCopyLog;
    private javax.swing.JButton buttonScan;
    private javax.swing.JButton buttonSetIP;
    private javax.swing.JButton buttonStartServer;
    private javax.swing.JButton buttonToggleSwitch;
    private javax.swing.JCheckBox checkboxAutoscroll;
    private javax.swing.JComboBox<String> comboLogLevel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JLabel labelClientConnectionIndicator;
    private javax.swing.JLabel labelServerRunningIndicator;
    private javax.swing.JLabel labelSwitchStateIndicator;
    private javax.swing.JTextArea logTextArea;
    private javax.swing.JProgressBar scanProgressBar;
    private javax.swing.JTextField serverPortTextArea;
    private javax.swing.JTextField textboxSwitchIP;
    // End of variables declaration//GEN-END:variables
}
